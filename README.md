QtCookiesSyn


C++ library based on QT5


Purpose

This library is about to solve the following problems:

1.The javascript class `XMLHttpRequest` in QML can't accept any cookies(QML doesn't support DOM, object `document.cookie` doesn't exist).

2.Cookies should be stored in local.

3.In the hyber apps, in order to keep log states, the session cookies, which contains the authorization info, should be unified between QML and H5.

4.From Qt5.6, webEngine(chromium) was import to substitute webkit module, which uses `profile` class to process cookies. To synchronize cookies between QML and webEngine is urgent issue.


Approach & Principle

In Qt, each network access is handled by an individual `networkAccessManager` instance. And each `networkAccessManager` has a default `cookieJar` component which handles cookies.

Create a user-defined cookieJar(cookie manager), implement cookies' save and load functions, make it as a singleton instance. Replace all `networkAccessManager` 's default `cookieJar` component with this user-defined cookieJar.

In Qml engine, replace the default `networkAccessManagerFactory`. This new factoy class can generate a `networkAccessManager` which contains a singleton `cookieJar`. The `cookieJar` can handle and store all cookies process by the networkAccessManagers. (For any QML component, whenever HTTP access needed, it turns to QMLEngine. QMLEngine will use the networkAccessManagerFactory to generate a networkAccessManager for service.) Then, after got reply, cookies will be sent to the cookieJar automatically.

(obsolete)For WebEngine, it use WebEngineCookieStore to store cookies. CookieJar can automatically synchronize cookies with WebEngineCookieStore. But not functional for android, because WebEngine module is not supported in android(currently Qt5.8.0).

For html, using QWebChannel to transport message between HTML and C++. On C++ side, expose the singleton `cookieJar` to JavaScript. On html side, using proper event handler such as window.onload() to save cookies to C++. On the other hand, html utilize the signal `synHtmlCookie` send from C++ side to set cookies from C++.


Roles

1.Class `QMLNetworkAccessManagerFactory`, inherit from `QQmlNetworkAccessManagerFactory`, is used to substitute the default networkAccessManagerFactory of QMLEngine. Each networkAccessManager generated by this factory contains a cookieJar which is singleton.

2.Class `NetworkCookieJar`, inherit from `QNetworkCookieJar`, is used to handle with cookies. Singleton, fufill cookies's save, load, insert, delete, update functions. 


Expose to html. 


SLOT for HTML: Q_INVOKABLE bool setHtmlCookiesFromUrl(const QString& rawString, const QUrl &url). 


SIGNAL for HTML: void synHtmlCookie( const QString& cookieStr ).


ToDo


How To Use?

1. include QtCookieSyn. 
2. create QQmlEngine
3. using MARCRO: START_COOKIE_SYN_WITH_HTML(x,y)
	x is instance of QQmlEngine
        y is WebSocket port, used by html page.
4. if you do NOT want expose to html, you could us MARCRO: START_COOKIE_SYN(x)
        x is instance of QQmlEngine

example:

#include `<QtCookieSyn>`

int main(int argc, char *argv[])

{

    QGuiApplication app(argc, argv);

    QtWebView::initialize();

    QQmlApplicationEngine engine;

    START_COOKIE_SYN_WITH_HTML(engine,12345)

    engine.load(QUrl(QStringLiteral("qrc:/qml/xmlhttprequest.qml")));

    return app.exec();

}

